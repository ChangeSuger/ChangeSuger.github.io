[{"title":"CRC校验位","url":"/2023/02/13/CRC%E6%A0%A1%E9%AA%8C%E4%BD%8D/","content":"校验位是为了保证数据在传输过程中的完整性，采用一种指定的算法对原始数据进行计算，得出的一个校验值。接收方接收到数据时，采用同样的校验算法对原始数据进行计算，如果计算结果和接收到的校验值一致，说明数据校验正确，这一帧数据可以使用，如果不一致，说明传输过程中出现了差错，这一帧数据丢弃，请求重发\n常用的校验算法有奇偶校验、校验和、CRC，还有 LRC、BCC 等不常用的校验算法\n循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的\n生成 CRC 校验位一个完整的 CRC 参数模型应该包含以下信息：\n\nNAME：参数模型名称\nWIDTH：宽度，即生成的 CRC 数据位宽，如 CRC-8，生成的 CRC 为 8 位\nPOLY：十六进制多项式，省略最高位1，如 x8 + x2 + x + 1，二进制为 1 0000 0111，省略最高位 1，转换为十六进制为 0x07\nINIT：CRC 初始值，和 WIDTH 位宽一致，默认 INIT = 0x00\nREFIN：true 或 false ，在进行计算之前，原始数据是否翻转，如原始数据：，如果 REFIN 为 true，进行翻转之后为  ，默认为 false\nREFOUT：true 或 false，运算完成之后，得到的 CRC 值是否进行翻转，如计算得到的 CRC 值：，如果 REFOUT 为 true ，进行翻转之后为  ，默认为 false\nXOROUT：计算结果与此参数进行异或运算后得到最终的 CRC 值，和 WIDTH 位宽一致，默认 XOROUT = 0x00\n\n计算步骤：\n\n原始数据与 INIT 进行异或运算（如果 INIT=0x00 ，则结果为原始数据）\n如果 REFIN = TURE ，则上一步处理后的数据进行翻转，否则什么也不干\n上一步处理后的数据左移 8 位，后面补 8 个 0\n上一步处理后的数据与 POLY 设置的多项式进行模2除法，取余数低8位\n上一步处理后的数据与 XOROUT 进行异或运算\n如果 REFOUT = TURE ，则上一步处理后的数据进行翻转，否则什么也不干\n输出结果为：原始数据 + CRC ，相当于原始数据左移 8 位 + 余数\n\n\n模2除法：\n\n被除数的首位为 1 ，商为 1\n被除数的首位为 0 ，商为 0\n模 2 除法等同于按位异或，要保证每次除完首位都为 0 ，才能进行右移\n计算时每次右移一位，当被除数的位数小于除数，其为余数\n\n\n计算示例：\n假设使用的 CRC-8/MAXIN ，其参数为：\nPOLY = 0x31 = 0011 0001INIT = 0x00XOROUT = 0x00REFIN = TRUEREFOUT = TRUE\n\n原始数据为 0x34 = 0011 0100 ：\n\nINIT = 0x00 → \nREFIN = TRUE →  ➡ \n ➡ \n\nXOROUT = 0x00 → \nREFOUT = TRUE →  ➡ \n输出结果： \n\n在线 CRC 计算器： Online CRC\n验证 CRC 校验位接收端的校验有两种方式：\n一种是和 CRC 计算一样，在本地把接收到的数据和 CRC 校验位分离，然后在本地对数据进行 CRC 运算，得到的 CRC 值和接收到的 CRC 进行比较，如果一致，说明数据接收正确，如果不一致，说明数据有错误\n另一种方法是把整个数据帧进行 CRC 运算，因为是数据帧相当于把原始数据左移 8 位，然后加上余数，如果直接对整个数据帧进行 CRC 运算（除以多项式），那么余数应该为 0 ，如果不为 0 说明数据出错\n在 python 实现 CRC 校验使用 python 库 crcmod\nimport crcmod# 可自行修改 crc 模型的参数# 目前的模型为 CRC-8/MAXINcrcFun = crcmod.mkCrcFun(0x131, initCrc=0x00, xorOut=0x00, rev=True)def crcCreat(data):    \"\"\"        生成 crc 校验位        data: bytes 类型    \"\"\"    return crcFun(data)def crcCheckResult(data, crc):    \"\"\"        验证 crc 校验位        data: bytes 类型        crc: bytes 类型    \"\"\"    if not crcFun(data + crc):        return True    else:        return False# 简单验证# input = int.to_bytes(52, length=1, byteorder='big')# print(crcCreat(input))# print(crcCheckResult(input, crcCreat(input).to_bytes(1, \"big\")))# for i in range(1,256):#     if crcCheckResult(input, int.to_bytes(i, 1, \"big\")):#         print(i)#         print(True)\n"},{"title":"Git 使用指南","url":"/2022/10/16/Git%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","content":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目\n\n想快速上手请跳转实例章节\n\n\n多用就会上手，一般常用的其实就那么几个\n\nGit 配置Git 中存在一些决定 Git 在各个环节的具体工作方式和行为的环境变量，这些变量可以存放在三个不同的地方：\n\n/etc/gitconfig ：对系统中所有用户都适用的配置，使用 git config --system 读写该文件\n~/.gitconfig ：用户目录下的配置文件，只适用于当前用户，使用 git config --global 读写该文件\n当前项目工作目录中的 .git/config ，该文件中的配置仅对当前项目有效，使用 git config --local 读写该文件\n\n配置优先级为：当前目录 &gt; 用户配置 &gt; 系统配置\ngit config使用 git config 命令可以查看和设置 git 的相关配置信息\n\ngit config -e | --edit ：编辑配置文件\n--local ：当前配置，未指定配置时默认读写该配置\n--global ：用户配置\n--system ：系统配置\n\n查看配置信息\n# 查看所有环境变量git config --list# 查看某个环境变量git config user.name\n\n用户信息\ngit config [--global] user.name \"Camille\"git config [--global] user.email xxxxxxxxx@xx.com\n\n\n每次 Git 提交都会使用该信息，优先设置\n\n文本编辑器\n设置 Git 默认使用的文本编辑器，默认为 Vim \ngit config [--global] core.editor emacs\n\n差异分析工具\n设置 Git 在使用 git diff 命令时默认使用的差异分析工具：\ngit config [--global] merge.tool vimdiff\n\n添加配置项\ngit config [–-local | –-global | –-system] –-add section.key value\n\nsection , key , value 三项都不能缺，否则会添加失败\ngit config --add site.name hisoten\n\n删除配置项\ngit config [–-local | –-global | –-system] –-unset section.key\n\n示例：\ngit config --unset site.name\n\n工作区 &amp; 暂存区 &amp; 版本库\n工作区（workspace）：在电脑里能看到的目录\n暂存区（staging area）：一般存放在 .git 目录下的 index 文件（**.git/index**）中\n版本库（repository）：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库\n\n基本操作\n遇事不决 git help \n\n创建仓库git initgit init 用于创建一个空的 Git 仓库或初始化一个现有的 Git 仓库\nGit 的大部分命令都需要在 Git 的仓库中才能运行，因此 git init 是使用 Git 的第一个命令\ngit init [&lt;directory&gt;]\n\n\ndirectory ：可选参数，指定初始化仓库的本地目录，默认为当前目录\n\n初始化后，指定目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中\ngit clonegit clone 用于将现有 Git 仓库中的项目拷贝到新目录\ngit clone &lt;repo&gt; [&lt;directory&gt;]\n\n\nrepo ：Git 版本仓库的地址\ndirectory ：可选参数，指定拷贝项目的本地目录，默认为当前目录\n\n\n使用 git clone 拷贝的项目不需要再使用 git init 进行初始化\n\ngit clone 支持多种协议，除了 HTTP(s) 以外，还支持 SSH、Git、本地文件协议等\n提交 &amp; 修改\n\n\n命令\n说明\n\n\n\ngit add\n添加文件到暂存区\n\n\ngit status\n查看仓库当前的状态，显示有变更的文件\n\n\ngit diff\n比较文件的不同，即暂存区和工作区的差异\n\n\ngit commit\n提交暂存区到本地仓库\n\n\ngit reset\n回退版本\n\n\ngit rm\n将文件从暂存区和工作区中删除\n\n\ngit mv\n移动或重命名工作区文件\n\n\ngit addgit add 用于将将修改添加到暂存区\ngit add [-u | --update] [&lt;file&gt; | &lt;directory&gt; | .]\n\n\n-u / --update ：只更新所有跟踪文件的修改到暂存区，忽略未被跟踪的文件的修改\n&lt;file&gt; ：添加一个或多个文件到暂存区，文件之间用空格隔开\n&lt;directory&gt; ：添加指定目录到暂存区，包括其子目录\ngit add . ：添加当前目录下的所有文件到暂存区\n\n默认情况下，git add 命令不会添加忽略的文件(.gitignore)，如果在命令行上显式指定了任何忽略的文件，git add 命令都将失败，并显示一个忽略文件的列表\n使用 -f 或 --force 参数可以强制添加被忽略的文件：\ngit add -f .\n\ngit statusgit status 用于查看工作目录和暂存区的状态，包括当前所处分支，上一次提交之后新增加的修改以及未被跟踪的文件列表\ngit status\n\n# 输出结果On branch mainYour branch is up to date with 'origin/main'.Changes not staged for commit:  (use \"git add &lt;file&gt;...\" to update what will be committed)  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)        modified:   \"\\345\\256\\236\\347\\224\\250\\345\\267\\245\\345\\205\\267/Git \\344\\275\\277\\347\\224\\250\\346\\214\\207\\345\\215\\227.md\"no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n使用 -s 参数可以获得简短的输出结果：\ngit status -s\n\n# 输出结果M \"\\345\\256\\236\\347\\224\\250\\345\\267\\245\\345\\205\\267/Git \\344\\275\\277\\347\\224\\250\\346\\214\\207\\345\\215\\227.md\n\n\n简短输出结果只显示已跟踪文件的修改\n\n忽略 untracked 文件\n未被 tracked 的文件分为两类：\n\n已添加到工作目录，但未执行 git add 添加到暂存区的文件\n各种编译过程中产生的程序文件，如 .pyc ， .obj ，.tmp ， .exe 等\n\n后者堆多了会使得 git status 输出很多没用的信息，应在 .gitignore 文件中将这些文件设为忽略，这样就不会被标记为 untracked 文件\ngit diffgit diff 用于比较文件的不同，即比较文件在暂存区和工作区的差异\n\ngit diff ：查看尚未缓存的改动\ngit diff -cached ：查看已缓存的改动（暂存区和上一次提交的差异）\n\n\ngit status 显示上次提交更新后的更改或者写入缓存的改动， 而 git diff 一行一行地显示这些改动具体是啥\n\ngit commitgit commit 用于将暂存区的内容添加到本地仓库中\ngit commit [&lt;file&gt; ...] -m [message]\n\n\n&lt;file&gt; ：指定提交到本地仓库的暂存区文件，默认为暂存区的全部文件\n[message] ：备注信息\n\n\n如果没有设置 -m 选项，Git 会尝试打开一个编辑器以填写提交信息。 如果 Git 在配置中找不到相关信息，默认会打开 vim\n\n使用 -a 参数可以自动将已被跟踪文件的修改提交到暂存区再提交到版本库：\ngit commit -am \"initial commit\"\n\n\n未被跟踪的文件不受影响\n\ngit resetgit reset 用于回退版本，将当前 HEAD 复位到指定状态，一般用于撤消之前的一些操作，如：git add ， git commit 等\ngit reset [--mixed | --soft | --hard] [HEAD] [&lt;file&gt; ...]\n\n\n--mixed ：默认参数，重置暂存区的文件与上一次的提交保持一致，工作区文件内容保持不变\n--soft ：回退到某个版本\n--hard ：撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交\n可以根据 commit_id 回退版本\n\n\nHEAD ：指定回退版本\nHEAD 或 HEAD~0  ：当前版本\nHEAD^ 或 HEAD~1 ：上一个版本\nHEAD^^ 或 HEAD~2  ：上上一个版本\nHEAD^^^ 或 HEAD~3  ：上上上一个版本\n…\n\n\n&lt;file&gt; ：指定要回退版本的文件，默认全部文件\n\n\n使用 git reset HEAD &lt;file&gt; 可以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存\n\ngit commit -a -m \"test\"git reset --soft HEAD^# 此处省略各种修改git commit -a -c ORIG_HEAD\n\n\n执行 git reset 命令时，git 会把老的 HEAD 拷贝到文件 .git/ORIG_HEAD 中，在命令中可以使用 ORIG_HEAD 引用这个提交，即使用上次的提交信息重新提交\n\ngit rmgit rm 用于从工作区和缓存区中删除文件\n使用  git rm 删除文件与手动删除文件的区别：\n\n使用 git rm 来删除文件，这个删除操作会被 Git 记录\n手动删除文件，仅仅是删除了物理文件，Git 不会记录这个删除操作\n\n\n如果手动删除已经被提交到缓存区过的文件，运行 git status 时就会在 Changes not staged for commit 中提示该文件的删除没有更新到缓存区\n\n将文件从暂存区和工作区中删除：\ngit rm &lt;file&gt;\n\n如果要删除之前修改过并且添加到暂存区，则必须要用 -f 参数，强行从暂存区和工作区中删除修改后的文件：\ngit rm -f &lt;file&gt;\n\n使用 --cached 参数可以仅把文件从暂存区域移除，保留当前工作目录中：\ngit rm -cached &lt;file&gt;\n\ngit mvgit mv 用于移动或重命名一个文件、目录或软连接\ngit mv [file] [newfile]\n\n如果新文件名已经存在，但还是要重命名，可以使用 -f 参数\n\n手动移动文件或目录时，运行 git status 时会发现，所有被移动的文件被记录为删除原文件，在新地址重新创建该文件\n\ngit taggit tag 用于给项目某一个阶段的代码打标签，通常用来记录版本快照，以及创建 release 版本\n\n标签本质上是某个 commit 的指针，但比 commit 号更方便记忆和管理\n\n创建标签：\ngit tag &lt;name&gt; [&lt;commit_id&gt;]\n\n创建标签时默认为当前的 commit 指针 HEAD 打标签，也可以通过 commit_id 指定需要打标签的 commit \n通过以下命令可以在打标签的同时添加标签信息：\ngit tag -a &lt;tag_name&gt; -m \"tag_info\" [&lt;commit_id&gt;]\n\n查看已有标签：\ngit tag\n\n查看某个标签的具体信息：\ngit show &lt;tag_name&gt;\n\n标签的具体信息中包含关联的 commit 的 commit_id ，可用于回退到指定版本\n\nREADME.md 中通常会有版本更新记录，可以根据此进行版本回退\n\n删除本地标签：\ngit tag -d &lt;tag_name&gt;\n\n本地的 tag 信息通常不会自动推送到远程代码块，需要推送 tag 时可以使用以下命令：\ngit push origin --tags\n\n分支操作git branchgit branch 用于列出，创建或删除分支\n查看已有分支：\ngit branch [-r | -a] [--list]\n\n\n--list ：列出现有的本地分支（无参数默认选项）\n-r ：列出远程分支\n-a ：列出所有本地分支和远程分支\n\n创建新分支：\ngit branch &lt;branch&gt;\n\n修改分支命名：\ngit branch -m [&lt;oldbranch&gt;] &lt;newbranch&gt;\n\n\n省略旧分支名时修改当前分支命名\n\n删除已有分支：\ngit branch -D &lt;branch&gt;\n\n\n在删除现有分支之前，请切换到其他分支\n\ngit mergegit merge 用于将两个或两个以上的分支合并到一起\n将指定分支（可以多个）合并到当前分支中，自动进行新的提交：\ngit merge &lt;...branch&gt;\n\ngit checkoutgit checkout 用于切换分支或恢复工作树文件，更新工作树中的文件以匹配索引或指定树中的版本\n切换到已有分支：\ngit checkout &lt;branch&gt;\n\n切换到新分支：\ngit checkout -b new_branch\n\n\ngit checkout 会重写工作区，比较危险\n\ngit stashgit stash 用于将工作目录中已有的更改暂时隐藏起来\n在一些特殊的场合，需要隐藏已有的更改才能使得 git 正常工作，如拉取与已有更改有严重冲突的代码、或者在不提交更改的情况下切分支\n隐藏当前工作目录下未提交的修改：\ngit stash [save]\n\n\n调用没有任何参数的 git stash 相当于 git stash save \n\n还原被隐藏的修改：\ngit stash pop\n\n远程操作git remotegit remote 命令用于进行远程仓库的操作\n查看所有远程仓库：\ngit remote -v\n\n显示某个远程仓库的信息：\ngit remote show [remote]\n\n\nremote ：远程仓库地址\n\n添加远程仓库：\ngit remote add [shortname] [url]\n\n\nshortname ：该远程仓库的别名\nurl ：该远程仓库的 url\n\n删除远程仓库：\ngit remote rm shortname\n\n修改远程仓库的别名：\ngit remote rename old_name new_name\n\ngit fetchgit fetch 命令用于从远程仓库拉取代码\ngit fetch &lt;远程主机名&gt; &lt;分支名&gt;\n\n拉取远程仓库指定分支的代码\n拉取代码后，会显示与当前分支代码的差异，可以在确认无误后使用 git merge 进行合并\ngit pullgit pull 命令用于从远程仓库拉取代码并合并本地\n\ngit pull 的功能相当于 git fetch 和  git merge \n\ngit pull &lt;远程主机名&gt; &lt;远程分支名&gt;:[&lt;本地分支名&gt;]\n\n\n&lt;远程仓库别名&gt; ：要拉取的远程仓库的别名\n&lt;远程分支名&gt; ：指定要拉取的远程仓库分支\n&lt;本地分支名&gt; ：指定要合并的本地分支版本，省略时合并到当前分支\n\ngit pushgit push 命令用于从将本地的分支版本上传到远程仓库的指定分支并合并\ngit push &lt;远程仓库别名&gt; &lt;本地分支名&gt;[:&lt;远程分支名&gt;]\n\n\n&lt;远程仓库别名&gt; ：要上传到的远程仓库的别名\n&lt;本地分支名&gt; ：指定要上传的本地分支版本\n&lt;远程分支名&gt; ：指定要上传到的远程仓库分支\n\ngit push origin master:master\n\n\n如果推送的远程仓库分支不存在，则会被新建\n\n如果本地分支名与远程分支名相同，则可以只填写本地分支名\ngit push origin master\n\n如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略\ngit push origin\n\n无参数时的推送行为\n如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认远程仓库，在不加任何参数使用 git push 时将会自动推送至该远程仓库\ngit push -u origin master\n\n不带任何参数 git push 有两种推送方法：\n\nsimple ：只推送当前分支，默认为该方法\nmatching ：推送所有有对应的远程分支的本地分支\n\n通过 git config 可以修改这个设置：\ngit config --global push.default simple\n\ngit config --global push.default matching\n\n全部推送\n使用 –all 参数，可以将本地的所有分支都推送到远程主机：\ngit push --all origin\n\n强制推送\n如果远程主机的版本比本地版本更新，推送时 Git 会报错，要求先在本地做 git pull 合并差异，然后再推送到远程主机\n通常建议合并差异后再推送，但如果一定要推送的话，可以使用 –force 参数强制推送：\ngit push --force origin master\n\n\n尽量避免使用 –-force \n\n删除远程仓库的分支\n使用 --delete 参数，可以删除远程仓库的指定分支：\ngit push origin --delete master \n\n省略本地分支名，也可以删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支：\ngit push origin :master\n\n.gitignore有些文件，比如日志，临时文件，编译的中间文件等实际上并不需要提交到代码库，因此不希望 Git 追踪这些文件，可以通过书写 .gitignore 文件来告诉 Git 哪些文件应该被忽略\n\n.gitignore 放在项目的根目录下\n\n\n在 .gitingore 文件中，每一行指定一个忽略规则，Git 检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：\n\n从命令行中读取可用的忽略规则\n当前目录定义的规则\n父级目录定义的规则，依次递推\n$GIT_DIR/info/exclude 文件中定义的规则\ncore.excludesfile 中定义的全局规则\n\n在 .gitignore 文件中，每一行的忽略规则的语法如下：\n空格不匹配任意文件，可作为分隔符，可用反斜杠转义开头的文件标识注释，可以使用反斜杠进行转义! 开头的模式标识否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用 ! 也不会再次被包含。可以使用反斜杠进行转义/ 结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件/ 开始的模式匹配项目跟目录如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录** 匹配多级目录，可在开始，中间，结束? 通用匹配单个字符* 通用匹配零个或多个字符[] 通用匹配单个字符列表\n\n常用匹配示例：\nbin/: 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件/bin: 忽略根目录下的bin文件/*.c: 忽略 cat.c，不忽略 build/cat.cdebug/*.obj: 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj**/foo: 忽略/foo, a/foo, a/b/foo等a/**/b: 忽略a/b, a/x/b, a/x/y/b等!/bin/run.sh: 不忽略 bin 目录下的 run.sh 文件*.log: 忽略所有 .log 文件config.php: 忽略当前路径的 config.php 文件\n\n\n❗ .gitignore 的设置只能让 Git 忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的，解决的办法是把本地缓存删除，然后再提交：\ngit rm -r --cached .git add .git commit -m \"update .gitignore\"\n\n通过 git check-ignore 指令可以查看一个文件是基于哪一条规则被忽略：\ngit check-ignore -v test.md&gt; .gitignore:7:test.md    test.md\n\n这个指令可以用于查找由于 .gitignore 规则书写错误而导致一些文件未被无法被添加到 Git 中的问题（虽然可以强制添加，但肯定还是 git add . 用起来更爽）\n实例\n太长不看，不如来点实用的.jpg\n\n全新仓库的首次提交git initgit add .git commit -m \"说明\"git branch -M maingit remote add origin https://github.com/………….gitgit push -u origin main\n\n更新代码git pullgit statusgit add .git commit -m \"说明\"git push\n\n\n说明为每次提交必须添加的字段，用于简要概述此次提交的内容\n\n删除远程关联如果 clone 下来一个别人的仓库，在此基础上完成代码，推送到自己的仓库可能遇到 error: remote origin already exists. ，解决方法：\ngit remote rm origingit remote add origin https://github.com/………….gitgit push origin master\n\n暂存修改切分支当前分支有未保存修改时是不能切分支的，如果需要将当前修改保存到其他分支，需要暂存未保存的修改：\ngit stashgit checkout [-b] branchgit stash pop\n\n拉取主分支同步更改git checkout mastergit pullgit checkout branchgit merge master\n\n\n有冲突的话需要本地手动合并\n\n在已 fork 项目中同步原始仓库新增的分支git remote add upstream &lt;原始仓库的 git 链接&gt;git fetch upstreamgit checkout -b &lt;想要同步的分支名&gt; upstream/&lt;想要同步的分支名&gt;git push origin &lt;想要同步的分支名&gt;\n\n其他连接优化国内连 Github 很容易炸，如果有魔法的话，可能更改代理端口来优化连接\ngit config --global http.proxy 127.0.0.1:7890git config --global https.proxy 127.0.0.1:7890\n\n\n最后的端口号根据本机的代理端口设置\n\n查看已有代理配置：\ngit config --global http.proxy # 查看 git 的 http 代理配置git config --global https.proxy # 查看 git 的 https 代理配置git config --global -l # 查看 git 的所有配置\n\n清除已有的代理配置：\ngit config --global --unset http.proxygit config --global --unset https.proxy\n","tags":["工具"]}]